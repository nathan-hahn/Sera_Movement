---
title: "Supplementary Materials: Movement Data and Activity Budgets"
output: html_notebook
---
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. Download rmd file in top right. 

1. Prepare movement data and calculate 14-day analysis periods
2. Fit and evaluate hidden Markov Models
3. Analysis of movement states

```{r echo=FALSE, warning = FALSE, message=FALSE}
library(tidyverse, quietly = TRUE)
library(lubridate, quietly = TRUE)
library(ggplot2, quietly = TRUE)
library(momentuHMM, quietly = TRUE)
library(overlapping, quietly = TRUE)
library(adehabitatLT, quietly = TRUE)

source('Sera_functions.R')

# Set environment to EAT
Sys.setenv(TZ="Africa/Nairobi") 
```

```{r}
rawData <- read.csv('./movdata/Sera_datasets_10Mar21.csv')
meta <- read.csv('./movdata/sera_metadata.csv')
rawData <- merge(rawData, meta, by = 'MovDataID')
```

### 1. Prep data
* Prep data and check fixes
* Create 14-day periods
* Calculate fix rates

```{r fig.width = 8}
## Prep and check data
sera <- data.prep(rawData, collar.data = c('Class', 'releaseDate', 'cohort'))

meta.table <- sera %>% group_by(MovDataID, CalcID, Class, releaseDate, cohort) %>%
  tally()

# viz of raw fix times
# p <- ggplot(sera, aes(x = Fixtime, y = minute(Fixtime))) + geom_point() + facet_wrap(.~MovDataID) +
#   ylab("minutes from 0")
# p + ggtitle('raw fixes')

# Downsample to clean up immobility alerts and recheck result. 
sera <- sera %>%
  filter(minute(Fixtime) > 55 | minute(Fixtime) < 5 | between(minute(Fixtime), 25, 35))

#Downsample to 1-hour because wild collars are on hourly schedule
sera <- sera %>%
  filter(minute(Fixtime) > 55 | minute(Fixtime) < 5)

# check downsample
p <- ggplot(sera, aes(x = Fixtime, y = minute(Fixtime))) + geom_point() + facet_wrap(.~MovDataID) +
  ylab("minutes from 0")
p + ggtitle('cleaned fixes')
```

##### Define 14-day periods
* Divide data into synchronized 14-day periods based on orphan cohort 1. Cohort 1 was released first, so periods are calculated relative to their release date. 0 = first week. Negative periods are 'pre-release'

```{r}
# define first release (cohort 1) as the date to base the 14 day slices on
release.date <- as.Date("2019-05-02")

# define sequence of dates for all tracking data
slice.df <- as.data.frame(seq(as.Date(min(sera$Fixtime)), as.Date(max(sera$Fixtime)), by="days"))
colnames(slice.df) <- 'date'

# create 14 day slices using the sequence of dates and add to dataframe
slice.length = 14
slice.df$slice <- as.numeric(slice.df$date - release.date[1]) %/% slice.length
# get start dates of each 14-day period
slice.df <- slice.df %>% group_by(slice) %>%
  mutate(slice.start = min(date))

# Join slice dataframe with full sera tracking dataframe
sera$date <- as.Date(sera$Fixtime)
sera <- merge(sera, slice.df, by = 'date')
sera$date <- NULL

# export 14-day periods metadata
t <- as.data.frame(cbind(levels(as.factor(slice.df$slice)), levels(as.factor(slice.df$slice.start))))
colnames(t) <- c('slice', 'slice.start')
write.csv(t, './movdata/14day_periods.csv')
```

##### Clean Trajectories 

```{r}
# Set burst function -- no relocs within 4 hours creates a separate burst
foo <- function(dt) {
  return(dt > (4*3600))
}

# regularize traj
sera <- as.data.frame(sera) #needs to be a dataframe to use infolocs
system.time({
  ele.traj <- traj.func(df = sera, fix.units = "hour", regular = TRUE, 
                        infolocs = sera[,c(1,6:10)]) 
})

# get fix success rate
t <- ele.traj$tracking.df %>%
  group_by(id) %>% 
  summarise(fix.rate = mean(!(is.na(x)))) %>%
  mutate(CalcID = as.factor(id))
# add to metadata table
meta.table <- merge(meta.table, t, by = 'CalcID')

meta.table
```

### 2. Fit hidden Markov models
* Filter out bursts with low fix rates (<95%) and <500 points. 
* HMMs are fit to bursts to avoid large data gaps between relocations (>4 hrs)
* We also take the log step length to improve fit (Polansky 2015).

##### Create dataframe

```{r}
library(momentuHMM)
# create burst filter list that meets HMM specs (>500 points in a burst, <5% missing data)
t <- filter.traj(df = ele.traj$summary.df, n.reloc = 500, p.missing = .05)
hmm.filter <- t$df

# all individuals are still included after filtering out bursts 
#levels(hmm.filter$id)

# check data loss after filtering out bursts - minimal
#1-sum(hmm.filter$nb.reloc)/dim(sera)[1]

# create HMM dataframe
sera.hmm <- filter(ele.traj$tracking.df, burst %in% hmm.filter$burst) %>%
  rename(ID = burst) # treat bursts as individuals for fitting
#sera.hmm <- subset(sera.hmm, !is.na(sera.hmm$x))

# prep data for HMM
sera.step <- prepData(sera.hmm)
sera.log.step <- sera.step
sera.log.step$step <- log(sera.log.step$step + 0.001) # add constant for zero steps
```


##### Fit HMMs

Fit models with two and three movement states. Models are initiated using parameters for mean log step length and turning angle concentrations for each state. Models fits are retried 5 times to optimize initiation parameters using maximum log likelihood.  

```{r warning=FALSE, results='hide',message=FALSE}
# state label
stateNames2 <- c("encamped", "exploratory")
stateNames3 <- c("encamped", "meandering", "dirwalk")

# set distributions
# distGam = list(step = "gamma", angle = "vm") # zero-inflated gamma distributions
distNorm = list(step = "norm", angle = "vm") # normal step distribution since we use log step length

# Null 2-state
par2 <- list(step = c(2, 6, 2, 1),
             angle = c(.2,.2)) 
system.time(
  mod2 <- fitHMM(data = sera.log.step, nbStates = 2, dist = distNorm,
                 Par0 = par2,
                 retryFits = 5,
                 stateName = stateNames2,
                 modelName = "twoStep")
)

# View model summary 
mod2

# Null 3-state
par3 <- list(step = c(1, 4, 6, 1.5, 1, 1),
             angle = c(.2,.2,.2)) 
             
system.time(
  mod3 <- fitHMM(data = sera.log.step, nbStates = 3, dist = distNorm,
                 Par0 = par3,
                 retryFits = 5,
                 stateName = stateNames3,
                 modelName = "threeState null")
)

```


```{r}
# top model output with 3 movement states
mod3
```

##### Diagnostics

Pseudo-residuals and autocorelation functions are used to assess the model fits. The autocorrelation is reduced in the 3-state model. Turning angle distributions are shown for each of the three classified states. 

```{r warning=FALSE, results='hide',message=FALSE}
# diagnostic plots. Some autocorrelation in the step lengths
plotPR(mod2)

plotPR(mod3)
```
The distribution of turning angles shows the concentration of straight-line movement (turning angle = 0) as movement states progress from encamped to directed walk.

```{r results='hold'}
# assign states using viterbi algorithm
sera.hmm$viterbi <- (viterbi(mod3)) 
sera.hmm$state <- as.factor(sera.hmm$viterbi)
levels(sera.hmm$state) <- c('encamped', 'meandering', 'dirwalk')

## Rose Diagrams
plotRA <- function(x) {
  rose.diag(x[!is.na(x$rel.angle),]$rel.angle, bins=24, prop=1.8,
            main=paste0("Relative Angles: ", unique(x$state)))
}

par(mfrow = c(1,3))
state.split <- split(sera.hmm, sera.hmm$viterbi)
plotRA(state.split[[1]])
plotRA(state.split[[2]])
plotRA(state.split[[3]])
```

```{r}
# filter out outlier steps 
split <- split(sera.hmm, sera.hmm$viterbi)
split[[1]] <- filter(split[[1]], dist <= median((split[[2]]$dist + runif(1, -200, 200)), na.rm = T))
split[[2]] <- filter(split[[2]], dist <= median((split[[3]]$dist + runif(1, -200, 200)), na.rm = T))
split[[3]] <- filter(split[[3]], dist >= median((split[[2]]$dist + runif(1, -200, 200)), na.rm = T))
hmm.df <- do.call(rbind, split)

# check step length distributions
boxplot(hmm.df$dist ~ hmm.df$cohort + hmm.df$viterbi)

```

### 3. Activity Budgets 
* Using 3-state model, calculate behavioral states
* Divide data into synchronized 14-day periods based on orphan cohort 1
* Assess activity budgets using state-level time density
* Assess activity time budgets (e.g. % time spent in each state over 14-day periods)

##### Time Density of Activity Budgets
* Assess activity budgets using state-level time density for the 14-day periods

Activity budgets over 14-day periods - all dates are relative to the first cohort's release date. 24-hour activity pattern density plots are faceted by relative period, showing pre and post release. There is immediate use of exploratory state after release, but the timing of exploratory movements changes within the first 

```{r, echo = FALSE, fig.height=20, fig.width=5}
# split out cohorts
split <- split(hmm.df, hmm.df$cohort)
cohort.1 <- split[[1]]
cohort.2 <- split[[2]]
cohort.3 <- split[[3]]
cohort.4 <- split[[4]]


t0 <- cohort.1
t1 <- cohort.4

budget <- ggplot() +
  facet_grid(slice~viterbi) + 
  geom_density(data = t0, aes(x = hour(date),
                   fill = factor(viterbi), colour = factor(cohort)), alpha = 0.3, adjust = 1.5) +
  geom_density(data = t1, aes(x = hour(date),
                              fill = factor(viterbi), colour = factor(cohort)), alpha = 0.3, adjust = 1.5) +
  
  # add sunrise/sunset
  geom_vline(xintercept=6
             ,color="dark grey", linetype="dashed", size=1) + 
  geom_vline(xintercept=18,
           color="dark grey", linetype="dashed", size=1) +

  # add colors
  scale_fill_manual(values = c("#E69F00", "#56B4E9", "#009E73"), name = c("state")) +
  scale_colour_manual(values = c("black", 'red' ), name = c("cohort")) +
  xlab("hour (0-23)") + ggtitle('Activity Budget - Cohort 1:Wild')
budget
```


```{r, echo = FALSE, fig.height=15, fig.width=5}
t0 <- cohort.2
t1 <- cohort.4
t1 <- subset(t1, t1$slice %in% unique(t0$slice))

budget <- ggplot() +
  facet_grid(slice~viterbi) + 
  geom_density(data = t0, aes(x = hour(date),
                   fill = factor(viterbi), colour = factor(cohort)), alpha = 0.3, adjust = 1.5) +
  geom_density(data = t1, aes(x = hour(date),
                              fill = factor(viterbi), colour = factor(cohort)), alpha = 0.3, adjust = 1.5) +
  
  # add sunrise/sunset
  geom_vline(xintercept=6
             ,color="dark grey", linetype="dashed", size=1) + 
  geom_vline(xintercept=18,
           color="dark grey", linetype="dashed", size=1) +

  # add colors
  scale_fill_manual(values = c("#E69F00", "#56B4E9", "#009E73"), name = c("state")) +
  scale_colour_manual(values = c("black", 'red' ), name = c("cohort")) +
  xlab("hour (0-23)") + ggtitle('Activity Budget - Cohort 2:Wild')
budget
```


```{r, echo = FALSE, fig.height=9, fig.width=5}
t0 <- cohort.3
t1 <- cohort.4
t1 <- subset(t1, t1$slice %in% unique(t0$slice))

budget <- ggplot() +
  facet_grid(slice~viterbi) + 
  geom_density(data = t0, aes(x = hour(date),
                   fill = factor(viterbi), colour = factor(cohort)), alpha = 0.3, adjust = 1.5) +
  geom_density(data = t1, aes(x = hour(date),
                              fill = factor(viterbi), colour = factor(cohort)), alpha = 0.3, adjust = 1.5) +
  
  # add sunrise/sunset
  geom_vline(xintercept=6
             ,color="dark grey", linetype="dashed", size=1) + 
  geom_vline(xintercept=18,
           color="dark grey", linetype="dashed", size=1) +

  # add colors
  scale_fill_manual(values = c("#E69F00", "#56B4E9", "#009E73"), name = c("state")) +
  scale_colour_manual(values = c("black", 'red' ), name = c("cohort")) +
  xlab("hour (0-23)") + ggtitle('Activity Budget - Cohort 3:Wild')
budget
```


##### Run overlap coefficient test
* Quantify pct overlap in the kernal density estimates of activity
* Comparisons run for each cohort against the wild group

```{r warning=FALSE, results='hide',message=FALSE}
## Prep cohort dataframes 

release.date <- as.Date(c("2019-05-02", "2019-11-16", "2020-05-28", "2019-05-30"))

# filter out pre-release data based on release date of each cohort, and split by relative time slice
cohort.1 <- subset(cohort.1, as.Date(cohort.1$date) >= release.date[1])
cohort.1.split <- split(cohort.1, cohort.1$slice)

cohort.2 <- subset(cohort.2, as.Date(cohort.2$date) >= release.date[2])
cohort.2.split <- split(cohort.2, cohort.2$slice)

cohort.3 <- subset(cohort.3, as.Date(cohort.3$date) >= release.date[3])
cohort.3.split <- split(cohort.3, cohort.3$slice)

# combine to single nested list of orphan cohorts 
cohort.all.list <- list(cohort.1.split, cohort.2.split, cohort.3.split) # all cohorts after filtering out pre-release data

# **for wild, must repeat the first 14 day period twice to compare with cohort 1's earlier release date 
wild.split <- split(cohort.4, cohort.4$slice)
t <- length(wild.split)
wild.split[[t+1]] <- wild.split[[2]]
wild.split[[t+1]]$slice <- 0
wild.split[[1]] <- wild.split[[2]]
wild.split[[1]]$slice <- 1
# Bind back together and check result
cohort.4 <- do.call(rbind, wild.split)
#plot_budget(cohort.4, facet = slice~viterbi, title = 'wild') # check
# **

# filter out slices with low amounts of data
n <- 100
cohort.all.list <- lapply(cohort.all.list, function(x) Filter(function(y) nrow(y) >= n, x))

library(overlapping)

## overlap test function - used in the for loop
overlap.test <- function(df, comp0, comp1, boot.it = 1000, plot = FALSE) {
  require(tidyverse)
  require(lubridate)
  require(overlapping)
  d0 <- dplyr::right_join(df, as.data.frame(comp0))
  d1 <- dplyr::right_join(df, as.data.frame(comp1))
  d <- list(as.numeric(hour(d0$date)), as.numeric(hour(d1$date)))
  
  # overlap and bootstrap test
  t <- overlap(d, plot = plot)
  boot <- boot.overlap(d, B = boot.it)
  boot$OVboot_stats
  
  return(list(d = df, bootstrap = boot))
  
}

## Cohort comp loop 
comp.all <- list()
OV_results <- list()
for(k in 1:3){ # orphan cohort loop - to be comped always with wild cohort 4
  for(i in 1:3){ # viterbi state
    for(j in 1:length(cohort.all.list[[k]])){ # slice loop must update for each cohort
      #create comps
      comp0 <- list(viterbi = as.integer(i), cohort = k, 
                    slice = unique(cohort.all.list[[k]][[j]]$slice)) # cohort number
      comp1 <- list(viterbi = as.integer(i), cohort = 4, 
                    slice = unique(cohort.all.list[[k]][[j]]$slice)) # comp is always wild cohort 4
      
      # run and store overlap output
      t <- overlap.test(df = rbind(cohort.all.list[[k]][[j]], cohort.4), comp0 = comp0, comp1 = comp1)
      name <- paste(as.integer(i), j,k,4, sep='-') #pattern = viterbi-slice-cohort-wild
      q <- quantile(t$bootstrap$OVboot_dist, probs = c(0.05, 0.95))
      
      # store OV stats, CIs, and comp info for sorting
      comp.all[[name]] <- t$bootstrap$OVboot_stats
      comp.all[[name]]$lwr <- as.numeric(q[1])
      comp.all[[name]]$upr <- as.numeric(q[2])
      comp.all[[name]]$viterbi <- comp0$viterbi
      comp.all[[name]]$cohort <- comp0$cohort
      comp.all[[name]]$slice <- comp0$slice
      comp.all[[name]]$slice.start <- unique(cohort.all.list[[k]][[j]]$slice.start)
      comp.all[[name]]$comp <- paste(k, 4, sep='-')
      
      # store OV bootstrap results
      OV_results[[j]] <- t$bootstrap$OVboot_dist
    }
  }
}

# join results into single dataframe
t <- do.call(rbind, comp.all)
```

Plotting the overlap estimates of activity between orphan cohorts and the wild group over time, no obvious trends were detected. X-axis corresponds to the 14-day time period. Plots are faceted by cohort comparison and behavioral state. 

```{r fig.width=8}
t$comp <- as.factor(t$comp)
levels(t$comp) <- c('cohort1-wild', 'cohort2-wild', 'cohort3-wild')
ggplot(t, aes(slice, estOV)) + geom_point(aes(color = state)) + facet_wrap(comp~state) +
  xlab('14-day periods') + ylab('Estimated overlap in 24-hour activity')
```

##### Activity Time Budets
* Calculate activity time budgets (pct. time spent in each state) over 14 day slices
* Plot the difference in time budgets over 14 day slices. Would expect these to get closer to zero if movement becomes more similar
* Boxplots of 14-day activity time budgets 
* Model differences in 14-day activity time budgets between each orphan cohort and the wild group. 

```{r fig.width=8}
library(DescTools)
# ag budget with 95% CIs
ag.budget <- rbind(cohort.1, cohort.2, cohort.3, cohort.4) %>%
  group_by(cohort, slice, viterbi) %>% tally() %>%
  group_by(cohort, slice) %>%
  mutate(prop = MultinomCI(n, conf.level = 0.95, sides = 'two.sided')[,1],
         lwr.ci = MultinomCI(n, conf.level = 0.95, sides = 'two.sided')[,2],
         upr.ci = MultinomCI(n, conf.level = 0.95, sides = 'two.sided')[,3],
  ) %>%
  mutate(cohort = as.factor(cohort), viterbi = as.factor(viterbi))

# budgets over time
ag.budget$state <- ag.budget$viterbi
levels(ag.budget$state) <- c('encamped', 'meandering', 'dirwalk')
levels(ag.budget$cohort) <- c('cohort 1', 'cohort 2', 'cohort 3', 'wild')
ggplot(ag.budget, aes(slice, y = prop, group = state)) + geom_point(aes(color = state), size = 1) + 
  geom_line(aes(color = state), linetype = 'dashed') +
  facet_grid(rows = vars(cohort), cols = vars(state)) +
  xlab('14-day period') + ggtitle('activity time budgets for each group (14-day)')
```

```{r}
t <- ag.budget
levels(t$viterbi) <- c("encamped", "meandering", "dir-walk")
t$cohort <- factor(t$cohort, levels = c("cohort 1", "cohort 2", "cohort 3", "wild"))

ggplot(t, aes(x = as.factor(viterbi), y = prop, fill = cohort)) + geom_boxplot() + ylab("proportion time spent in state") + xlab("behavioral state")

```

Construct state-level models of activity time budgets by cohort. A model is run for each behavioral state. Addition of a random effect for 14-day period (slice) to account for repeated observations. 

The results suggest that cohort 1 and 2 spent significantly more time in directed walk movements than the wild cohort, and significantly less time in encamped movements. The reference level for each model is the wild cohort. 

```{r message=FALSE}
# set reference level
ag.budget2 <- ag.budget
ag.budget2$cohort <- relevel(ag.budget2$cohort, ref = 'wild') # ref is resident wild pop for comparison
ag.budget2$time.period <- ag.budget$slice

## construct models by state

#encamped
t <- filter(ag.budget2, viterbi == 1) %>% rename(prop.encamped = prop)
m.encamped <- lm(prop.encamped ~ cohort + time.period, data = t)
summary(m.encamped)
confint(m.encamped)

#meandering
t <- filter(ag.budget2, viterbi == 2) %>% rename(prop.meandering = prop)
m.meandering <- lm(prop.meandering ~ cohort + time.period, data = t)
summary(m.meandering)
confint(m.meandering)

#dir-walk
t <- filter(ag.budget2, viterbi == 3) %>% rename(prop.dirwalk = prop)
m.dirwalk <- lm(prop.dirwalk ~ cohort + time.period, data = t)
summary(m.dirwalk)
confint(m.dirwalk)

fig5 <- sjPlot::plot_models(m.encamped, m.meandering, m.dirwalk, legend.title = 'Behavioral State', colors = scales::hue_pal(direction = -1)(3)) + ylim(limits = c(-0.5, .5))
fig5
```

##### Differences in Activity Time Budgets
From the regression models, we found that there are some differences in time budgets between the groups. We can calculate the difference in percent time spent in each state for all 14-day periods and plot them over time to vizualize these differences. As the regression model identified, there are not any evident temporal trends. 

```{r}
# get differences between movement phases
split <- split(ag.budget, ag.budget$cohort)
wild <- split[[4]]
split[[4]] <- NULL

for(i in 1:3){
  split[[i]] <- merge(split[[i]], wild, by = c("slice", 'viterbi'))
  split[[i]]$diff <- (split[[i]]$prop.x - split[[i]]$prop.y) # use 'abs' to get absolute difference
  split[[i]]$viterbi.y <- NULL
}
diff <- do.call(rbind, split)
diff$state <- diff$viterbi
levels(diff$state) <- c("encamped", "meandering", "dir-walk")
```


```{r fig.width=8}
#' There is not much temporal pattern here. 
#' Columns correspond to behavioral state, rows correspond to each orphan cohort
fig6 <- ggplot(diff, aes(x = slice, y = diff, group = state)) + geom_point(aes(color = state), size = 1) + 
  geom_line(aes(color = state), linetype = "dashed") + geom_hline(yintercept = 0) + 
  facet_grid(rows = vars(cohort.x), cols = vars(state)) +
  xlab('14-day period') + ylab('difference in activity time budget') +
  ggtitle('Difference in activity time budgets between cohorts and wild (14-day)')
fig6
```


